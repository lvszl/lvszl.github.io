---
title: Xv6 book——文件描述符与管道
data: 2023-8-18
categories: MIT-Xv6
# tags: 随笔
---

# Xv6 book——文件描述符与管道

一个进程可以通过系统调用 `fork()`来创建一个新的进程。`fork `创建的新进程被称为子进程，子进程的内存内容同创建它的进程（父进程）一样。`fork `函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。


文件描述符是一个整数，代表了一个进程可以读写的被内核管理的对象。
进程可以通过创建一个管道（pipe）或者赋值已经存在的文件描述符来获得一个文件描述符。
我们常把文件描述符指向的对象称为“文件”。
每个进程都有一个表，xv6的内核以文件描述符作为这张表的索引。进程从文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。
一些系统调用：
```cpp 
read(fd, buf, n)
```
从fd中读取最多n个字节（因为fd可能没n个字节），然后将他拷贝buf中，然后返回读出的字节数。每一个指向文件的文件描述符都和一个偏移关联。read从当前文件偏移处读取数据，然后把偏移增加读出字节数。紧随其后的read会从新的起点开始读数据。当没有数据可读时，read就会返回0，这就表示文件结束了。
```cpp
write(fd, buf, n)
```
写`buf`中的 `n` 个字节到fd并且返回实际写出的字节数。如果返回值小于 `n` 那么只可能是发生了错误。就像`read`一样，`write`也从当前文件的偏移处开始写，在写的过程中增加这个偏移。
cat程序注释
下面这段程序（实际上就是cat的本质实现）将数据从标准输入复制到标准输出，如果遇到了错误，它会在标准错误输出输出一条信息。
```cpp
char buf[512];
int n;

for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0)  //读完了
        break;
    if(n < 0){  // 读入错误，因此利用文件描述符“2”来指示错误输出
        fprintf(2, "read error\n");  // 用文件描述符2
        exit();
    }
    if(write(1, buf, n) != n){  // 写错误，因此利用文件描述符“2”来指示错误输出
        fprintf(2, "write error\n");
        exit();
    }
}
```
系统调用`close`会释放一个文件描述符，使得它未来可以被`open`,`pipe`,`dup`等调用重用。一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。
# 用fork和文件描述符实现I/O重定向
`fork`会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。
exec 会替换调用它的进程的内存但会保存它的文件描述符表。
这种行为使得 shell 可以这样实现重定向：`fork`一个进程，重新打开指定文件的文件描述符，然后执行新的程序。

# 管道
管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。

该事例代码运行程序`wc`，该程序的标准输出绑定到了一个管道的**读**端口

**示例代码**
```cpp
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) { // 子进程
    close(0);
    dup(p[0]);  // 复制：子进程将管道的读端口拷贝在描述符0上
    close(p[0]);  //关闭 p 中的描述符
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```
