#! https://zhuanlan.zhihu.com/p/651208925
---
title: Xv6 book——文件描述符与管道
data: 2023-8-18
categories: MIT-Xv6
# tags: 随笔
---
# Xv6 book——文件描述符与管道

一个进程可以通过系统调用 `fork()`来创建一个新的进程。`fork `创建的新进程被称为子进程，子进程的内存内容同创建它的进程（父进程）一样。`fork `函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。

文件描述符是一个整数，代表了一个进程可以读写的被内核管理的对象。
进程可以通过创建一个管道（pipe）或者赋值已经存在的文件描述符来获得一个文件描述符。
我们常把文件描述符指向的对象称为“文件”。
每个进程都有一个表，xv6的内核以文件描述符作为这张表的索引。进程从文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。
一些系统调用：

```cpp
read(fd, buf, n)
```

从fd中读取最多n个字节（因为fd可能没n个字节），然后将他拷贝buf中，然后**返回读出的字节数**。每一个指向文件的文件描述符都和一个偏移关联。read从当前文件偏移处读取数据，然后把偏移增加读出字节数。紧随其后的read会从新的起点开始读数据。当没有数据可读时，read就会返回0，这就表示文件结束了。

```cpp
write(fd, buf, n)
```

写 `buf`中的 `n` 个字节到fd并且返回实际写出的字节数。如果返回值小于 `n` 那么只可能是发生了错误。就像 `read`一样，`write`也从当前文件的偏移处开始写，在写的过程中增加这个偏移。
cat程序注释
下面这段程序（实际上就是cat的本质实现）将数据从标准输入复制到标准输出，如果遇到了错误，它会在标准错误输出输出一条信息。

```cpp
char buf[512];
int n;

for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0)  //读完了
        break;
    if(n < 0){  // 读入错误，因此利用文件描述符“2”来指示错误输出
        fprintf(2, "read error\n");  // 用文件描述符2
        exit();
    }
    if(write(1, buf, n) != n){  // 写错误，因此利用文件描述符“2”来指示错误输出
        fprintf(2, "write error\n");
        exit();
    }
}
```

系统调用 `close`会释放一个文件描述符，使得它未来可以被 `open`,`pipe`,`dup`等调用重用。一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符。



## 文件描述符

[参考](https://blog.csdn.net/qq_45831156/article/details/107469716)

在linux中，有默认的文件描述符：

而在Linux 系统中，有默认文件描述符
0 标准输入
1 标准输出
2 标准错误输出
给了三个宏定义：
**0：STDIN_FILENO**
**1：STDOUT_FILENO**
**2：STDERR_FILENO**

在之前的代码中，我们能够发现，`printf("%d",fd)`；结果都是从3开始，那么0 1 2是什么呢？

其实是这样的，在程序刚开始运行时，有三个文件被自动打开了，占用了 0 1 2 这三个描述符：
依次打开的三个文件分别是/dev/stdin，/dev/stdout，/dev/stderr

程序开始运行时，默认会调用open("/dev/stdin", O_RDONLY)将其打开，返回的文件描述符是0
在打开这个以后，再执行：open("/dev/stdout", O_WRONLY)； 所以这个文件的返回值自然是 1

使用0这个文件描述符，可以从键盘输入的数据简单理解就是，/dev/stdin这个文件代表了键盘。

所以就可以使用 read() 来达到类似于 scanf() 的结果，读取键盘输入的字符，放到缓存的 readbuf 中
其实 scanf() 这个库函数就是在调用 read() 只是从 read() 读取的内容往往只能是字符串，而若想将其从字符串转化为 整型，浮点型等，则（反正我不会搞）
其实如果你在代码中输入了 close(0); 你会发现，你的 scanf() 函数立马抓瞎，当场报废。

而 /dev/stdout：标准输出文件，fd = 1；则代表了 显示器，所以可以将 readbuf 中的数据写到屏幕上。
其实：printf(）下层调用的就是 write 函数。
同理，之所以使用 printf() 而不是write() 的原因，就是因为
库函数可以很好的兼容不同的OS
封装时，叠加了很多的功能，比如格式化转换通过指定%d、%f等，自动将其换为对应的字符，然后write输出，完全不用自己来转换。printf使用%s、%c输出字符串和字符时，其实不用转，因为要输出的本来就是字符，printf直接把字符给write就行了，当然也不是一点事情也不做，还是会做点小处理的。

**`read(0, &xx, sizeof(xx))`** 就表示从键盘中读取东西，存放到xx中，并且read返回读取的字节数，如果没东西读，则返回0。

# 用fork和文件描述符实现I/O重定向

`fork`会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。
exec 会替换调用它的进程的内存但会保存它的文件描述符表。
这种行为使得 shell 可以这样实现重定向：`fork`一个进程，重新打开指定文件的文件描述符，然后执行新的程序。

# 管道

管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。

该事例代码运行程序 `wc`，该程序的标准输出绑定到了一个管道的**读**端口

**示例代码**

```cpp
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) { // 子进程
    close(0);
    dup(p[0]);  // 复制：子进程将管道的读端口拷贝在描述符0上
    close(p[0]);  //关闭 p 中的描述符
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    write(p[1], "hello world\n", 12);
    close(p[0]);
    close(p[1]);
}
```

使用pipe(A) // A为一个数组，会得到一个长度为2 的int型的数组，其中，0用于从管道读取数据的文件描述符，1为用于从管道写入数据的文件描述符。
